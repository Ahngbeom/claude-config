#!/bin/bash
# Generated by cc-statusline (https://www.npmjs.com/package/@chongdashu/cc-statusline)
# Custom Claude Code statusline - Created: 2025-08-20T20:57:28.459Z
# Theme: detailed | Colors: true | Features: directory, git, model, context, usage, session, tokens, burnrate

input=$(cat)

# ---- color helpers (force colors for Claude Code) ----
use_color=1
[ -n "$NO_COLOR" ] && use_color=0

C() { if [ "$use_color" -eq 1 ]; then printf '\033[%sm' "$1"; fi; }
RST() { if [ "$use_color" -eq 1 ]; then printf '\033[0m'; fi; }

# ---- modern sleek colors ----
dir_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;117m'; fi; }    # sky blue
model_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;147m'; fi; }  # light purple  
version_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;180m'; fi; } # soft yellow
cc_version_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;249m'; fi; } # light gray
style_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;245m'; fi; } # gray
rst() { if [ "$use_color" -eq 1 ]; then printf '\033[0m'; fi; }

# ---- time helpers ----
to_epoch() {
  ts="$1"
  if command -v gdate >/dev/null 2>&1; then gdate -d "$ts" +%s 2>/dev/null && return; fi
  date -u -j -f "%Y-%m-%dT%H:%M:%S%z" "${ts/Z/+0000}" +%s 2>/dev/null && return
  python3 - "$ts" <<'PY' 2>/dev/null
import sys, datetime
s=sys.argv[1].replace('Z','+00:00')
print(int(datetime.datetime.fromisoformat(s).timestamp()))
PY
}

fmt_time_hm() {
  epoch="$1"
  if date -r 0 +%s >/dev/null 2>&1; then date -r "$epoch" +"%H:%M"; else date -d "@$epoch" +"%H:%M"; fi
}

progress_bar() {
  pct="${1:-0}"; width="${2:-10}"
  [[ "$pct" =~ ^[0-9]+$ ]] || pct=0; ((pct<0))&&pct=0; ((pct>100))&&pct=100
  filled=$(( pct * width / 100 )); empty=$(( width - filled ))
  printf '%*s' "$filled" '' | tr ' ' '='
  printf '%*s' "$empty" '' | tr ' ' '-'
}

# git utilities
num_or_zero() { v="$1"; [[ "$v" =~ ^[0-9]+$ ]] && echo "$v" || echo 0; }

# Function to add commas to numbers
add_commas() {
  local num="$1"
  if [[ "$num" =~ ^[0-9]+$ ]]; then
    printf "%'d" "$num" 2>/dev/null || echo "$num"
  else
    echo "$num"
  fi
}

# Function to format tokens with K/M units
format_tokens() {
  local num="$1"
  if [[ "$num" =~ ^[0-9]+$ ]]; then
    if [ "$num" -ge 1000000 ]; then
      awk "BEGIN {printf \"%.2fM\", $num / 1000000}"
    elif [ "$num" -ge 1000 ]; then
      awk "BEGIN {printf \"%.1fK\", $num / 1000}"
    else
      echo "$num"
    fi
  else
    echo "$num"
  fi
}

# ---- cache helpers for ccusage data ----
CACHE_FILE="$HOME/.claude/stats-cache.json"
CACHE_TTL=60  # 60 seconds

read_cache() {
  if [ -f "$CACHE_FILE" ]; then
    cache_ts=$(jq -r '.timestamp // 0' "$CACHE_FILE" 2>/dev/null)
    now_ts=$(date +%s)
    if [ $((now_ts - cache_ts)) -lt $CACHE_TTL ]; then
      cat "$CACHE_FILE"
      return 0
    fi
  fi
  return 1
}

update_cache_background() {
  (
    today_date=$(date +%Y%m%d)
    blocks=$(npx ccusage@latest blocks --json 2>/dev/null || ccusage blocks --json 2>/dev/null)
    daily=$(npx ccusage@latest daily --json --since "$today_date" 2>/dev/null || ccusage daily --json --since "$today_date" 2>/dev/null)
    weekly=$(npx ccusage@latest weekly --json 2>/dev/null || ccusage weekly --json 2>/dev/null)
    monthly=$(npx ccusage@latest monthly --json 2>/dev/null || ccusage monthly --json 2>/dev/null)

    # Only write if we got valid data
    if [ -n "$blocks" ]; then
      jq -n \
        --argjson ts "$(date +%s)" \
        --argjson blocks "$blocks" \
        --argjson daily "${daily:-null}" \
        --argjson weekly "${weekly:-null}" \
        --argjson monthly "${monthly:-null}" \
        '{timestamp: $ts, blocks: $blocks, daily: $daily, weekly: $weekly, monthly: $monthly}' \
        > "$CACHE_FILE" 2>/dev/null
    fi
  ) &
}

# ---- basics ----
if command -v jq >/dev/null 2>&1; then
  current_dir=$(echo "$input" | jq -r '.workspace.current_dir // .cwd // "unknown"' 2>/dev/null | sed "s|^$HOME|~|g")
  model_name=$(echo "$input" | jq -r '.model.display_name // "Claude"' 2>/dev/null)
  model_version=$(echo "$input" | jq -r '.model.version // ""' 2>/dev/null)
  session_id=$(echo "$input" | jq -r '.session_id // ""' 2>/dev/null)
  cc_version=$(echo "$input" | jq -r '.version // ""' 2>/dev/null)
  output_style=$(echo "$input" | jq -r '.output_style.name // ""' 2>/dev/null)
else
  current_dir="unknown"
  model_name="Claude"; model_version=""
  session_id=""
  cc_version=""
  output_style=""
fi

# ---- git colors ----
git_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;150m'; fi; }  # soft green
rst() { if [ "$use_color" -eq 1 ]; then printf '\033[0m'; fi; }

# ---- git ----
git_branch=""
if git rev-parse --git-dir >/dev/null 2>&1; then
  git_branch=$(git branch --show-current 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
fi

# ---- context window calculation ----
context_pct=""
context_used_tokens=""
context_max_tokens=""
context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[1;37m'; fi; }  # default white

# ---- Model-specific token usage (initialize) ----
sonnet_tokens=0
opus_tokens=0
haiku_tokens=0

# Determine max context based on model
get_max_context() {
  local model_name="$1"
  case "$model_name" in
    *"Opus 4"*|*"opus 4"*|*"Opus"*|*"opus"*)
      echo "200000"  # 200K for all Opus versions
      ;;
    *"Sonnet 4"*|*"sonnet 4"*|*"Sonnet 3.5"*|*"sonnet 3.5"*|*"Sonnet"*|*"sonnet"*)
      echo "200000"  # 200K for Sonnet 3.5+ and 4.x
      ;;
    *"Haiku 3.5"*|*"haiku 3.5"*|*"Haiku 4"*|*"haiku 4"*|*"Haiku"*|*"haiku"*)
      echo "200000"  # 200K for modern Haiku
      ;;
    *"Claude 3 Haiku"*|*"claude 3 haiku"*)
      echo "100000"  # 100K for original Claude 3 Haiku
      ;;
    *)
      echo "200000"  # Default to 200K
      ;;
  esac
}

if [ -n "$session_id" ] && command -v jq >/dev/null 2>&1; then
  MAX_CONTEXT=$(get_max_context "$model_name")
  
  # Convert current dir to session file path
  project_dir=$(echo "$current_dir" | sed "s|~|$HOME|g" | sed 's|/|-|g' | sed 's|\.|-|g' | sed 's|^-||')
  session_file="$HOME/.claude/projects/-${project_dir}/${session_id}.jsonl"
  
  if [ -f "$session_file" ]; then
    # Get the latest input token count from the session file
    latest_tokens=$(tail -20 "$session_file" | jq -r 'select(.message.usage) | .message.usage | ((.input_tokens // 0) + (.cache_read_input_tokens // 0))' 2>/dev/null | tail -1)
    
    if [ -n "$latest_tokens" ] && [ "$latest_tokens" -gt 0 ]; then
      context_used_tokens="$latest_tokens"
      context_max_tokens="$MAX_CONTEXT"
      context_used_pct=$(( latest_tokens * 100 / MAX_CONTEXT ))
      context_remaining_pct=$(( 100 - context_used_pct ))

      # Set color based on remaining percentage
      if [ "$context_remaining_pct" -le 20 ]; then
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;203m'; fi; }  # coral red
      elif [ "$context_remaining_pct" -le 40 ]; then
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;215m'; fi; }  # peach
      else
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;158m'; fi; }  # mint green
      fi

      context_pct="${context_remaining_pct}%"
    fi

    # ---- Model-specific token usage ----
    # Extract per-model token counts from session file (JSONL format - one JSON per line)
    if [ -f "$session_file" ]; then
      # Aggregate tokens by model (input + cache_read)
      sonnet_tokens=$(jq 'select(.message.model | test("sonnet")) | .message.usage | ((.input_tokens // 0) + (.cache_read_input_tokens // 0))' "$session_file" 2>/dev/null | jq -s 'add // 0')
      opus_tokens=$(jq 'select(.message.model | test("opus")) | .message.usage | ((.input_tokens // 0) + (.cache_read_input_tokens // 0))' "$session_file" 2>/dev/null | jq -s 'add // 0')
      haiku_tokens=$(jq 'select(.message.model | test("haiku")) | .message.usage | ((.input_tokens // 0) + (.cache_read_input_tokens // 0))' "$session_file" 2>/dev/null | jq -s 'add // 0')

      # Ensure numeric values
      sonnet_tokens=$(num_or_zero "$sonnet_tokens")
      opus_tokens=$(num_or_zero "$opus_tokens")
      haiku_tokens=$(num_or_zero "$haiku_tokens")
    fi
  fi
fi

# ---- usage colors ----
usage_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;189m'; fi; }  # lavender
cost_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;222m'; fi; }   # light gold
burn_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;220m'; fi; }   # bright gold
session_color() { 
  rem_pct=$(( 100 - session_pct ))
  if   (( rem_pct <= 10 )); then SCLR='38;5;210'  # light pink
  elif (( rem_pct <= 25 )); then SCLR='38;5;228'  # light yellow  
  else                          SCLR='38;5;194'; fi  # light green
  if [ "$use_color" -eq 1 ]; then printf '\033[%sm' "$SCLR"; fi
}

# ---- ccusage integration ----
session_txt=""; session_pct=0; session_bar=""
cost_usd=""; cost_per_hour=""; tpm=""; tot_tokens=""
today_tokens=""; today_cost=""
week_tokens=""; week_cost=""
month_tokens=""; month_cost=""
cache_hit_rate=""

if command -v jq >/dev/null 2>&1; then
  # Try to read from cache first
  cached_data=""
  if cached_data=$(read_cache); then
    # Cache hit - use cached data
    blocks_output=$(echo "$cached_data" | jq '.blocks' 2>/dev/null)
    daily_output=$(echo "$cached_data" | jq '.daily' 2>/dev/null)
    weekly_output=$(echo "$cached_data" | jq '.weekly' 2>/dev/null)
    monthly_output=$(echo "$cached_data" | jq '.monthly' 2>/dev/null)
  else
    # Cache miss - fetch blocks synchronously (essential data)
    blocks_output=$(npx ccusage@latest blocks --json 2>/dev/null || ccusage blocks --json 2>/dev/null)
    daily_output=""
    weekly_output=""
    monthly_output=""
    # Update cache in background for next time
    update_cache_background
  fi

  if [ -n "$blocks_output" ] && [ "$blocks_output" != "null" ]; then
    active_block=$(echo "$blocks_output" | jq -c '.blocks[] | select(.isActive == true)' 2>/dev/null | head -n1)
    if [ -n "$active_block" ]; then
      cost_usd=$(echo "$active_block" | jq -r '.costUSD // empty')
      cost_per_hour=$(echo "$active_block" | jq -r '.burnRate.costPerHour // empty')
      tot_tokens=$(echo "$active_block" | jq -r '.totalTokens // empty')
      tpm=$(echo "$active_block" | jq -r '.burnRate.tokensPerMinute // empty')

      # Cache hit rate calculation
      cache_read=$(echo "$active_block" | jq -r '.tokenCounts.cacheReadInputTokens // 0' 2>/dev/null)
      cache_creation=$(echo "$active_block" | jq -r '.tokenCounts.cacheCreationInputTokens // 0' 2>/dev/null)
      cache_read=$(num_or_zero "$cache_read")
      cache_creation=$(num_or_zero "$cache_creation")
      total_cache=$((cache_read + cache_creation))
      if [ "$total_cache" -gt 0 ]; then
        cache_hit_rate=$((cache_read * 100 / total_cache))
      fi

      # Session time calculation
      reset_time_str=$(echo "$active_block" | jq -r '.usageLimitResetTime // .endTime // empty')
      start_time_str=$(echo "$active_block" | jq -r '.startTime // empty')

      if [ -n "$reset_time_str" ] && [ -n "$start_time_str" ]; then
        start_sec=$(to_epoch "$start_time_str"); end_sec=$(to_epoch "$reset_time_str"); now_sec=$(date +%s)
        total=$(( end_sec - start_sec )); (( total<1 )) && total=1
        elapsed=$(( now_sec - start_sec )); (( elapsed<0 ))&&elapsed=0; (( elapsed>total ))&&elapsed=$total
        session_pct=$(( elapsed * 100 / total ))
        remaining=$(( end_sec - now_sec )); (( remaining<0 )) && remaining=0
        rh=$(( remaining / 3600 )); rm=$(( (remaining % 3600) / 60 ))
        end_hm=$(fmt_time_hm "$end_sec")
        session_txt="$(printf '%dh %dm until reset at %s (%d%%)' "$rh" "$rm" "$end_hm" "$session_pct")"
        session_bar=$(progress_bar "$session_pct" 10)
      fi
    fi
  fi

  # Today's daily usage (first element = today)
  if [ -n "$daily_output" ] && [ "$daily_output" != "null" ]; then
    today_tokens=$(echo "$daily_output" | jq -r '.daily[0].totalTokens // empty' 2>/dev/null)
    today_cost=$(echo "$daily_output" | jq -r '.daily[0].totalCost // empty' 2>/dev/null)
  fi

  # Weekly usage (last element = current week)
  if [ -n "$weekly_output" ] && [ "$weekly_output" != "null" ]; then
    week_tokens=$(echo "$weekly_output" | jq -r '.weekly[-1].totalTokens // empty' 2>/dev/null)
    week_cost=$(echo "$weekly_output" | jq -r '.weekly[-1].totalCost // empty' 2>/dev/null)
  fi

  # Monthly usage (last element = current month)
  if [ -n "$monthly_output" ] && [ "$monthly_output" != "null" ]; then
    month_tokens=$(echo "$monthly_output" | jq -r '.monthly[-1].totalTokens // empty' 2>/dev/null)
    month_cost=$(echo "$monthly_output" | jq -r '.monthly[-1].totalCost // empty' 2>/dev/null)
  fi
fi

# ---- render statusline ----
# Separator color
sep_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;240m'; fi; }  # dark gray

# Model colors (define early)
sonnet_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;147m'; fi; }  # light purple
opus_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;210m'; fi; }    # coral
haiku_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;158m'; fi; }   # mint green

# Usage colors
today_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;153m'; fi; }  # light blue
week_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;183m'; fi; }   # light pink
month_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;216m'; fi; }  # light coral

# Line 1: Core info (directory, git, model, claude code version, output style)
printf 'ðŸ“ %s%s%s' "$(dir_color)" "$current_dir" "$(rst)"
if [ -n "$git_branch" ]; then
  printf '  ðŸŒ¿ %s%s%s' "$(git_color)" "$git_branch" "$(rst)"
fi
printf '  ðŸ¤– %s%s%s' "$(model_color)" "$model_name" "$(rst)"
if [ -n "$model_version" ] && [ "$model_version" != "null" ]; then
  printf '  ðŸ·ï¸ %s%s%s' "$(version_color)" "$model_version" "$(rst)"
fi
if [ -n "$cc_version" ] && [ "$cc_version" != "null" ]; then
  printf '  ðŸ“Ÿ %sv%s%s' "$(cc_version_color)" "$cc_version" "$(rst)"
fi
if [ -n "$output_style" ] && [ "$output_style" != "null" ]; then
  printf '  ðŸŽ¨ %s%s%s' "$(style_color)" "$output_style" "$(rst)"
fi

# Separator line
printf '\n%sâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€%s' "$(sep_color)" "$(rst)"

# Line 2: Session info (tokens, reset time, cache, speed)
session_parts=()

# Session tokens
if [ -n "$tot_tokens" ] && [[ "$tot_tokens" =~ ^[0-9]+$ ]]; then
  session_parts+=("$(format_tokens "$tot_tokens") tokens")
fi

# Time remaining with gauge
if [ -n "$rh" ] || [ -n "$rm" ]; then
  session_bar=$(progress_bar "$session_pct" 10)
  session_parts+=("Reset: ${rh}h ${rm}m [${session_bar}]")
fi

# Cache hit rate
if [ -n "$cache_hit_rate" ] && [[ "$cache_hit_rate" =~ ^[0-9]+$ ]]; then
  session_parts+=("Cache: ${cache_hit_rate}%")
fi

# Speed (tokens per minute)
if [ -n "$tpm" ] && [[ "$tpm" =~ ^[0-9.]+$ ]]; then
  tpm_formatted=$(format_tokens "$(printf '%.0f' "$tpm")")
  session_parts+=("Speed: ${tpm_formatted}/min")
fi

# Build session line
if [ ${#session_parts[@]} -gt 0 ]; then
  session_content=""
  for i in "${!session_parts[@]}"; do
    if [ "$i" -gt 0 ]; then
      session_content="${session_content} | "
    fi
    session_content="${session_content}${session_parts[$i]}"
  done
  printf '\nðŸ’¬ %sSession: %s%s' "$(usage_color)" "$session_content" "$(rst)"
fi

# Line 3: Context window info
if [ -n "$context_pct" ] && [ -n "$context_used_tokens" ]; then
  context_bar=$(progress_bar "$context_remaining_pct" 10)
  used_formatted=$(format_tokens "$context_used_tokens")
  max_formatted=$(format_tokens "$context_max_tokens")
  printf '\nðŸ§  %sContext: %s / %s (%s%% left) [%s]%s' "$(context_color)" "$used_formatted" "$max_formatted" "$context_remaining_pct" "$context_bar" "$(rst)"
else
  printf '\nðŸ§  %sContext: TBD%s' "$(context_color)" "$(rst)"
fi

# Line 4: Model-specific token usage
model_parts=()

if [ "$sonnet_tokens" -gt 0 ] 2>/dev/null; then
  sonnet_formatted=$(format_tokens "$sonnet_tokens")
  model_parts+=("$(sonnet_color)Sonnet: ${sonnet_formatted}$(rst)")
fi
if [ "$opus_tokens" -gt 0 ] 2>/dev/null; then
  opus_formatted=$(format_tokens "$opus_tokens")
  model_parts+=("$(opus_color)Opus: ${opus_formatted}$(rst)")
fi
if [ "$haiku_tokens" -gt 0 ] 2>/dev/null; then
  haiku_formatted=$(format_tokens "$haiku_tokens")
  model_parts+=("$(haiku_color)Haiku: ${haiku_formatted}$(rst)")
fi

if [ ${#model_parts[@]} -gt 0 ]; then
  model_content=""
  for i in "${!model_parts[@]}"; do
    if [ "$i" -gt 0 ]; then
      model_content="${model_content} | "
    fi
    model_content="${model_content}${model_parts[$i]}"
  done
  printf '\nðŸŽ¯ Models: %s' "$model_content"
fi

# Line 5: Daily, Weekly, Monthly usage
usage_parts=()

# Today's usage
if [ -n "$today_tokens" ] && [[ "$today_tokens" =~ ^[0-9]+$ ]]; then
  today_tokens_formatted=$(format_tokens "$today_tokens")
  if [ -n "$today_cost" ] && [[ "$today_cost" =~ ^[0-9.]+$ ]]; then
    today_cost_formatted=$(printf '%.2f' "$today_cost")
    usage_parts+=("$(today_color)Today: ${today_tokens_formatted} (\$${today_cost_formatted})$(rst)")
  else
    usage_parts+=("$(today_color)Today: ${today_tokens_formatted}$(rst)")
  fi
fi

# Weekly usage
if [ -n "$week_tokens" ] && [[ "$week_tokens" =~ ^[0-9]+$ ]]; then
  week_tokens_formatted=$(format_tokens "$week_tokens")
  if [ -n "$week_cost" ] && [[ "$week_cost" =~ ^[0-9.]+$ ]]; then
    week_cost_formatted=$(printf '%.2f' "$week_cost")
    usage_parts+=("$(week_color)Week: ${week_tokens_formatted} (\$${week_cost_formatted})$(rst)")
  else
    usage_parts+=("$(week_color)Week: ${week_tokens_formatted}$(rst)")
  fi
fi

# Monthly usage
if [ -n "$month_tokens" ] && [[ "$month_tokens" =~ ^[0-9]+$ ]]; then
  month_tokens_formatted=$(format_tokens "$month_tokens")
  if [ -n "$month_cost" ] && [[ "$month_cost" =~ ^[0-9.]+$ ]]; then
    month_cost_formatted=$(printf '%.2f' "$month_cost")
    usage_parts+=("$(month_color)Month: ${month_tokens_formatted} (\$${month_cost_formatted})$(rst)")
  else
    usage_parts+=("$(month_color)Month: ${month_tokens_formatted}$(rst)")
  fi
fi

if [ ${#usage_parts[@]} -gt 0 ]; then
  usage_content=""
  for i in "${!usage_parts[@]}"; do
    if [ "$i" -gt 0 ]; then
      usage_content="${usage_content} | "
    fi
    usage_content="${usage_content}${usage_parts[$i]}"
  done
  printf '\nðŸ“Š Usage: %s' "$usage_content"
fi

printf '\n'